<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>  
    body {
        background-color: white;
        padding: 100px;
        width: 1000px;
        margin: auto;
        text-align: left;
        font-weight: 300;
        font-family: 'Open Sans', sans-serif;
        color: #121212;
    }
    h1, h2, h3, h4 {
        font-family: 'Source Sans Pro', sans-serif;
    }
    kbd {
        color: #121212;
    }
  </style> 
<title>CS184 Final Project</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>
<body>
<br />
<h1 align="middle">Project Milestone: Basic Tattoo Art</h1>
    <h2 align="middle">Team Members: Michelle Chen, Jojo Chen, Isabelle Liu, Nicholas Cheng</h2>
    <div class="padded">

        <p>
			After receiving our feedback, we reassessed our timeline and decided to focus on creating tattoo stencils (2D images) for our project deliverables. We'll still be keeping our GUI as a stretch goal but our main priority will be making sure our tattoo styles are rendered effectively.
        </p>

        <h3 align="middle">Milestone Progress and Preliminary Results</h3>
        <i>
          <b>
            <p>
              Stick and poke tattoo
            </p>
          </b>
        </i>
        <p>
			    Stick and poke tattooing seeks to create an image with a collection of dots of varying density to mimic shading. Images are generally grayscale and may or may not have an outline. On a high level, to create this effect, we first determined a grayscale value for each pixel. Since the density of dots create the values in stick and poke tattoos, we mimicked the effect by coloring each pixel either black or white according to a probability generated by their grayscale value. Therefore, pixels with a lower grayscale value (closer to white) have a higher probability of getting filled in with white and vice versa.  
		    </p>
        <p>
          More specifically, we altered the PathTracer::raytrace_pixel() function. After generating the average value of the samples taken, we took the average of the rgb values((r+g+b)/3). This generates a grayscale equivalent using the average method described in the link below. If we set each of r, g, and b to this average value, we get a grayscale equivalent of our original color (rgb(avg_val, avg_val, avg_val)). 
        </p>
        <a href="https://www.baeldung.com/cs/convert-rgb-to-grayscale">Average method description</a>
       <p>
        Then, we want to decide whether to fill in the pixel with black or white based on this average value. Since the RGB values are between 0 and 1, we used the value directly as a probability. According to that probability, we generated random values to determine where the pixel would be colored white. For example, if our average value was 0.1, then the pixel would have a 10% chance of being colored white. We also added an offset of 0.035 (which we found works well via experimentation) which helped bring more white spots to the rendering, which stick and poke tends to have. Finally, we used update_pixel() to add the white or black color to our sampleBuffer. 
       </p>
       <p>
        During the process, we experimented with a couple of other ways to achieve this effect that failed. We first tried to generalize each tile to one value and randomly color in pixels according to the corresponding probability in the RaytracedRenderer::raytrace_tile() function. However, the tiles were too large for the images to be legible since a lot of the details were abstracted away. We also tried to make these tiles smaller, but discovered that calculating probabilities based on each pixel produced the most legible results. We also tried to reveal more white parts by eliminating midtones and just making them white, but found that this created unpredictable results depending on the lighting of the original image. Adding an offset to our average worked out a lot better. 
       </p>
        <p>
          Below are two examples of what our current rendering looks like. 
        </p>
      <div align="middle">
            <table style="width:100%">
              <tr align="center">
                <td>
                  <img src="images/stick-poke-ball.png" alt=""align="middle" width="400px"/>
                  <figcaption>Sketch tattoo of CBspheres.dae</figcaption>
                </td>
                <td>
                  <img src="images/stick-poke-bunny.png" alt=""align="middle" width="400px"/>
                  <figcaption>Sketch tattoo of CBbunny.dae</figcaption>
                </td>
              </tr>
            </table>
        </div>
        <i>
          <b>
            <p>
              American Traditional Tattoo
            </p>
          </b>
        </i>
    	<h3 align="middle">Updated Project Timeline</h3>
        <p>
			Description
		</p>
		
		<h3 align="middle">Milestone Video</h3>
     <a href="https://drive.google.com/file/d/1babn7IxkwgxeEhENOrLaTIM_noR_NC3R/view?usp=sharing" target="_blank">Video Link</a>

		<h3 align="middle">Milestone Slides</h3>
			<a href="https://docs.google.com/presentation/d/1fPxzrZsT_1i5AFyzw8coGeYwAmfLgTNXTm7P-z1D3X0/edit?usp=sharing" target="_blank">Presentation Link</a>

</body>
</html>
